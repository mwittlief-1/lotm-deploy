import type { CourtOfficerRole, CourtRoster, CourtRosterRow, Person, RunState } from "./types";
import { Rng } from "./rng";

// v0.2.4 Court + Household integration.
// Tooling/QA note: Court officer generation must be deterministic and stream-isolated.

const MALE_NAMES = ["Edmund", "Hugh", "Robert", "Walter", "Geoffrey", "Aldric", "Oswin", "Giles", "Roger", "Simon"];
const FEMALE_NAMES = ["Matilda", "Alice", "Joan", "Agnes", "Isolde", "Edith", "Beatrice", "Margery", "Cecily", "Elinor"];

function pickName(rng: Rng, sex: "M" | "F"): string {
  return sex === "M" ? rng.pick(MALE_NAMES) : rng.pick(FEMALE_NAMES);
}

function traitLevel(rng: Rng): number {
  const r = rng.next();
  if (r < 0.03) return 1;
  if (r < 0.17) return 2;
  if (r < 0.83) return 3;
  if (r < 0.97) return 4;
  return 5;
}

function genTraits(rng: Rng, id: string) {
  // Keep trait generation deterministic but stream-isolated.
  const base = rng.fork(`traits:${id}`);
  return {
    stewardship: traitLevel(base.fork("stew")),
    martial: traitLevel(base.fork("mart")),
    diplomacy: traitLevel(base.fork("dip")),
    discipline: traitLevel(base.fork("disc")),
    fertility: traitLevel(base.fork("fert"))
  };
}

function officerTitle(role: CourtOfficerRole): "Steward" | "Clerk" | "Marshal" {
  if (role === "steward") return "Steward";
  if (role === "clerk") return "Clerk";
  return "Marshal";
}

function defaultOfficerId(role: CourtOfficerRole): string {
  return `p_court_${role}`;
}

function mkOfficerPerson(rng: Rng, id: string, role: CourtOfficerRole): Person {
  // Very small flavor, but deterministic and bounded.
  const sex: "M" | "F" = rng.bool(role === "marshal" ? 0.75 : 0.6) ? "M" : "F";
  const age = rng.int(28, 55);
  const name = pickName(rng.fork("name"), sex);
  return {
    id,
    name: `${name}`,
    sex,
    age,
    alive: true,
    traits: genTraits(rng, id),
    married: false
  };
}

function getHouseRegistry(state: RunState): any {
  const anyState: any = state as any;
  const playerHouseId: string = typeof anyState.player_house_id === "string" ? anyState.player_house_id : "h_player";
  const houses: any = anyState.houses;
  if (!houses || typeof houses !== "object") return null;
  const h = houses[playerHouseId];
  if (!h || typeof h !== "object") return null;
  return h;
}

export function ensureCourtOfficers(state: RunState): void {
  const anyState: any = state as any;
  if (!anyState.people || !anyState.houses) return;

  const playerHouseId: string = typeof anyState.player_house_id === "string" ? anyState.player_house_id : "h_player";
  const houses: any = anyState.houses;
  if (!houses[playerHouseId] || typeof houses[playerHouseId] !== "object") {
    houses[playerHouseId] = { id: playerHouseId };
  }
  const houseRec: any = houses[playerHouseId];

  if (!houseRec.court_officers || typeof houseRec.court_officers !== "object") houseRec.court_officers = {};
  if (!Array.isArray(houseRec.court_extra_ids)) houseRec.court_extra_ids = [];

  const people: Record<string, Person> = anyState.people as Record<string, Person>;

  const base = new Rng(state.run_seed, "court", 0, "court_officers/v0.2.4");

  const roles: CourtOfficerRole[] = ["steward", "clerk", "marshal"];
  for (const role of roles) {
    const cur = houseRec.court_officers?.[role];
    const id = typeof cur === "string" && cur.length > 0 ? cur : defaultOfficerId(role);
    houseRec.court_officers[role] = id;
    if (!people[id]) {
      const r = base.fork(`role/${role}`);
      people[id] = mkOfficerPerson(r, id, role);
    }
  }
}

export function getCourtOfficerIds(state: RunState): Array<{ role: CourtOfficerRole; person_id: string }> {
  const h = getHouseRegistry(state);
  const out: Array<{ role: CourtOfficerRole; person_id: string }> = [];
  const roles: CourtOfficerRole[] = ["steward", "clerk", "marshal"];
  for (const role of roles) {
    const pid = h?.court_officers?.[role];
    if (typeof pid === "string" && pid.length > 0) out.push({ role, person_id: pid });
  }
  return out;
}

export function getCourtExtraIds(state: RunState): string[] {
  const h = getHouseRegistry(state);
  const raw: any[] = Array.isArray(h?.court_extra_ids) ? h.court_extra_ids : [];
  const out: string[] = [];
  for (const x of raw) {
    if (typeof x === "string" && x.length > 0) out.push(x);
  }
  return out;
}

export function addCourtExtraId(state: RunState, personId: string): void {
  if (!personId) return;
  const anyState: any = state as any;
  const playerHouseId: string = typeof anyState.player_house_id === "string" ? anyState.player_house_id : "h_player";
  const houses: any = anyState.houses;
  if (!houses || typeof houses !== "object") return;
  if (!houses[playerHouseId] || typeof houses[playerHouseId] !== "object") houses[playerHouseId] = { id: playerHouseId };
  const h = houses[playerHouseId];
  const raw: any[] = Array.isArray(h.court_extra_ids) ? h.court_extra_ids : [];
  const ids = raw.filter((x) => typeof x === "string" && x.length > 0);
  if (!ids.includes(personId)) ids.push(personId);
  h.court_extra_ids = ids;
}

export function deriveCourtMemberIds(state: RunState): string[] {
  // Stable ordering: head, spouse, children (oldest->youngest, id tie-break), officers (fixed role order), extras (id asc).
  const anyState: any = state as any;
  const people: Record<string, Person> = (anyState.people ?? {}) as any;

  const ids: string[] = [];
  const seen = new Set<string>();
  const push = (id: string | null | undefined) => {
    if (!id || typeof id !== "string") return;
    if (seen.has(id)) return;
    if (!people[id]) return; // skip unknown IDs
    seen.add(id);
    ids.push(id);
  };

  push(state.house.head?.id);
  push(state.house.spouse?.id ?? null);

  const kids = [...(state.house.children ?? [])].sort((a, b) => {
    if (b.age !== a.age) return b.age - a.age;
    return String(a.id).localeCompare(String(b.id));
  });
  for (const c of kids) push(c.id);

  for (const { role, person_id } of getCourtOfficerIds(state)) {
    // ensure stable role ordering by iterating fixed role order in getCourtOfficerIds
    push(person_id);
  }

  const extras = getCourtExtraIds(state).slice().sort((a, b) => a.localeCompare(b));
  for (const id of extras) push(id);

  return ids;
}

export function buildCourtRoster_v0_2_4(state: RunState): CourtRoster {
  const anyState: any = state as any;
  const people: Record<string, Person> = (anyState.people ?? {}) as any;

  const heirId = state.house.heir_id ?? null;
  const spouse = state.house.spouse ?? null;

  // Widow semantics: same as household roster.
  let widowedPersonId: string | null = null;
  if (spouse) {
    if (state.house.head.alive && !spouse.alive) widowedPersonId = state.house.head.id;
    else if (!state.house.head.alive && spouse.alive) widowedPersonId = spouse.id;
  }

  const rows: CourtRosterRow[] = [];
  const seen = new Set<string>();

  const pushRow = (personId: string, role: CourtRosterRow["role"], officer_role?: CourtRosterRow["officer_role"]) => {
    if (!personId || typeof personId !== "string") return;
    if (seen.has(personId)) return;
    const p = people[personId];
    if (!p) return;
    seen.add(personId);

    const badges: CourtRosterRow["badges"] = [];
    if (!p.alive) badges.push("deceased");
    if (p.alive && widowedPersonId === p.id) badges.push(p.sex === "M" ? "widower" : "widow");
    if (heirId && p.id === heirId) badges.push("heir");

    rows.push({ person_id: p.id, role, officer_role: officer_role ?? null, badges });
  };

  // Family
  pushRow(state.house.head.id, "head");
  if (state.house.spouse) pushRow(state.house.spouse.id, "spouse");
  const kids = [...(state.house.children ?? [])].sort((a, b) => {
    if (b.age !== a.age) return b.age - a.age;
    return String(a.id).localeCompare(String(b.id));
  });
  for (const c of kids) pushRow(c.id, "child");

  // Officers
  for (const { role, person_id } of getCourtOfficerIds(state)) {
    pushRow(person_id, "officer", role);
  }

  // Married-in spouses (extras)
  const extras = getCourtExtraIds(state).slice().sort((a, b) => a.localeCompare(b));
  for (const id of extras) pushRow(id, "married_in_spouse");

  const headcount_alive = rows.reduce((acc, r) => (r.badges.includes("deceased") ? acc : acc + 1), 0);

  return {
    schema_version: "court_roster_v1",
    turn_index: state.turn_index,
    headcount_alive,
    rows
  };
}

export function courtConsumptionBushels_v0_2_4(state: RunState, bushelsPerPersonPerYear: number, turnYears: number): {
  court_headcount: number;
  court_consumption_bushels: number;
  court_roster: CourtRoster;
} {
  const roster = buildCourtRoster_v0_2_4(state);
  const headcount = roster.headcount_alive;
  const courtConsumption = Math.max(0, Math.floor(headcount * bushelsPerPersonPerYear * turnYears));
  return { court_headcount: headcount, court_consumption_bushels: courtConsumption, court_roster: roster };
}
