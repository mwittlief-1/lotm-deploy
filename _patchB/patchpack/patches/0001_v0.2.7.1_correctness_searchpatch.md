# v0.2.7.1 Correctness Hotfix — Copy/Paste Patch Instructions

> This file captures the **exact edit instructions** from the prior thread.
> Apply them to the certified baseline repo, then build your overlay zip in your normal workflow.

---

## Overlay contents (files to include in the overlay zip)

- `src/sim/turn.ts`
- `src/sim/types.ts`
- `src/sim/peopleFirst.ts`
- `src/sim/court.ts`
- `src/App.tsx` (minimal wiring for P0.3 + P0.5)
- `tests/v0271_hotfix_p0_correctness.test.ts`
- `DEV_NOTES.md`

If you run no-deps gates, also mirror to:

- `dist_batch/src/sim/turn.js`
- `dist_batch/src/sim/peopleFirst.js`
- `dist_batch/src/sim/court.js`

---

## 1) P0.1 Aging invariant (all instantiated registry people age +3)

### `src/sim/turn.ts` — patch `householdPhase()`

Find this line inside `householdPhase`:

```ts
for (const p of people) p.age += 3;
```

Replace it with:

```ts
  // v0.2.7.1 HOTFIX: Aging invariant — every instantiated person in People/Registry ages +TURN_YEARS per turn.
  {
    const anyState: any = state as any;
    const reg: Record<string, Person> | undefined = anyState.people as any;
    if (reg) {
      for (const p of Object.values(reg)) {
        if (!p || typeof p !== "object") continue;
        if (!p.alive) continue; // keep age-at-death stable
        p.age += TURN_YEARS;
      }
    } else {
      // legacy fallback: only the bounded household/court set
      for (const p of people) {
        if (!p.alive) continue;
        p.age += TURN_YEARS;
      }
    }
  }
```

---

## 2) P0.2 + P0.3 Death-turn HoH consistency + succession spouse swap

### `src/sim/turn.ts` — add helpers near `closeTurn`

Insert these helper functions **above** `function closeTurn(...):`

```ts
function spouseIdFromKinship(state: RunState, personId: string): string | null {
  const anyState: any = state as any;
  const edges = (anyState.kinship_edges ?? []) as any[];
  for (const e of edges) {
    if (!e || e.kind !== "spouse_of") continue;
    if (e.a_id === personId) return e.b_id;
    if (e.b_id === personId) return e.a_id;
  }
  return null;
}

function ensureKinshipSpouseOf(state: RunState, aId: string, bId: string): void {
  if (!aId || !bId || aId === bId) return;
  const anyState: any = state as any;
  anyState.kinship_edges = (anyState.kinship_edges ?? []) as any[];
  const edges = anyState.kinship_edges as any[];
  const exists = edges.some((e) => e?.kind === "spouse_of" && ((e.a_id === aId && e.b_id === bId) || (e.a_id === bId && e.b_id === aId)));
  if (!exists) edges.push({ kind: "spouse_of", a_id: aId, b_id: bId });
}

function addCourtExtraId(state: RunState, personId: string): void {
  if (!personId) return;
  const anyState: any = state as any;
  anyState.court_extra_ids = (anyState.court_extra_ids ?? []) as string[];
  const xs: string[] = anyState.court_extra_ids;
  if (!xs.includes(personId)) xs.push(personId);
}

function resolveSuccessionNow_v0_2_7_1(state: RunState, houseLog: HouseLogEvent[], reportNotes?: string[]): void {
  if (state.house.head.alive) return;

  const heirId = computeHeirId(state);
  if (!heirId) {
    state.game_over = { reason: "DeathNoHeir", turn_index: state.turn_index };
    return;
  }

  const priorSpouseId = state.house.spouse?.id ?? null;

  // Promote heir
  const idx = state.house.children.findIndex((c) => c.id === heirId);
  const heir = state.house.children.splice(idx, 1)[0]!;
  heir.married = true;
  state.house.head = heir;

  // v0.2.6.1 WP-12: married-out head is now in-court
  removeCourtExcludeId(state, heir.id);

  // Swap spouse to new HoH spouse (if any)
  const anyState: any = state as any;
  const reg: Record<string, Person> | undefined = anyState.people as any;
  const heirSpouseId = spouseIdFromKinship(state, heir.id);
  if (heirSpouseId && reg?.[heirSpouseId]) {
    state.house.spouse = reg[heirSpouseId];
    state.house.spouse_status = "spouse";
  } else {
    // No spouse known → clear active spouse slot
    state.house.spouse = undefined;
    state.house.spouse_status = undefined;
  }

  // Prior HoH spouse becomes dowager: keep visible via court extras; widow badge comes from houseLog widowed.survivor_id
  if (priorSpouseId && priorSpouseId !== state.house.spouse?.id) {
    addCourtExtraId(state, priorSpouseId);
  }

  houseLog.push({ kind: "succession", turn_index: state.turn_index, new_ruler_name: heir.name });

  // Recompute heir after succession (same turn)
  const prev = state.house.heir_id ?? null;
  const next = computeHeirId(state);
  if (next && next !== prev) {
    const nm = state.house.children.find((c) => c.id === next)?.name;
    if (nm) houseLog.push({ kind: "heir_selected", turn_index: state.turn_index, heir_name: nm });
  }

  if (reportNotes) reportNotes.push("Succession resolved.");
}
```

### `src/sim/turn.ts` — call succession in `proposeTurn` (same-turn report correctness)

Find in `proposeTurn` right after:

```ts
const hh = householdPhase(working, houseLog);
```

…and after the “Recompute heir after births/deaths” block, insert:

```ts
  // v0.2.7.1 HOTFIX: If HoH died this processed turn, resolve succession now so Turn Report/preview never shows a dead ruler.
  resolveSuccessionNow_v0_2_7_1(working, houseLog);
```

### `src/sim/turn.ts` — replace `closeTurn`’s existing “succession (minimal)” block

In `closeTurn`, replace the whole block:

```ts
  // succession (minimal)
  if (!state.house.head.alive) {
    ...
  }
```

with:

```ts
  // v0.2.7.1 HOTFIX: succession semantics unified (HoH swap + spouse swap + dowager visibility).
  resolveSuccessionNow_v0_2_7_1(state, houseLog, reportNotes);
  if (state.game_over) return;
```

---

## 3) P0.4 Marriage acceptance must deterministically wire spouse + residency

### `src/sim/turn.ts` — in both acceptance paths, add spouse edge

A) In `applyMarriageDecision` accept path

After the code marks the child as married and identifies spouse person id, add:

```ts
ensureKinshipSpouseOf(state, child.id, offer.house_person_id);
```

B) In `applyProspectsDecision` marriage accept path

After it determines `subject_id` and the spouse person id, add:

```ts
ensureKinshipSpouseOf(state, subjectId, spousePersonId);
```

(This keeps succession eligibility unchanged; residency remains via court_exclude_ids/court_extra_ids only.)

---

## 4) P0.3 Court roster widow badge must stay correct after spouse swap

### `src/sim/court.ts` — derive widow target from `houseLog` when available

Change function signatures:

Replace:

```ts
export function buildCourtRoster_v0_2_4(state: RunState): CourtRoster {
```

with:

```ts
export function buildCourtRoster_v0_2_4(state: RunState, houseLog?: HouseLogEvent[]): CourtRoster {
```

Then replace the widow computation block with:

```ts
  // Widow semantics: prefer explicit life log (same-turn correctness); fallback to head/spouse alive mismatch.
  let widowedPersonId: string | null = null;
  if (houseLog && houseLog.length) {
    const w = [...houseLog].reverse().find((e) => e.kind === "widowed" && e.survivor_id);
    if (w?.survivor_id) widowedPersonId = w.survivor_id;
  }
  if (!widowedPersonId && spouse) {
    if (state.house.head.alive && !spouse.alive) widowedPersonId = state.house.head.id;
    else if (!state.house.head.alive && spouse.alive) widowedPersonId = spouse.id;
  }
```

Update court consumption wrapper:

Replace:

```ts
export function courtConsumptionBushels_v0_2_4(state: RunState, bushelsPerPersonPerYear: number, turnYears: number): { ... } {
  const roster = buildCourtRoster_v0_2_4(state);
```

with:

```ts
export function courtConsumptionBushels_v0_2_4(state: RunState, bushelsPerPersonPerYear: number, turnYears: number, houseLog?: HouseLogEvent[]): { ... } {
  const roster = buildCourtRoster_v0_2_4(state, houseLog);
```

And in `src/sim/turn.ts` call site, change:

```ts
const court = courtConsumptionBushels_v0_2_4(working, ...);
```

to:

```ts
const court = courtConsumptionBushels_v0_2_4(working, ..., houseLog);
```

---

## 5) P0.5 Prospect effects must appear next turn with source=prospect

This is UI attribution (no new mechanics). Minimal wiring:

### `src/App.tsx`

Where Diff Ledger lines are built (look for the section that renders “decision | event | system_pressure | prospect”), add:

- Parse previous turn’s `prospects_log` (from last resolved turn log entry)
- For each `prospect_accepted` with `effects_applied`:
  - add a “Coin” driver line with `source="prospect"` and `why=summary`
  - add relationship delta driver lines similarly (A/R/T)

(This uses existing actual deltas; no invented probabilities.)

---

## 6) P0.1 Gate test

Create `tests/v0271_hotfix_p0_correctness.test.ts`:

- Creates a run
- Ensures there is at least one extra person in `state.people` not in household/court
- Runs one turn via `proposeTurn` + `applyDecisions` with a no-op decisions object
- Asserts ages of all alive people increased by 3

A template is included in this zip at `new_files/tests/v0271_hotfix_p0_correctness.test.ts`.

---

## Create the overlay zip locally (after applying)

From repo root:

```bash
zip -r devB_patch_v0.2.7.1_correctness_overlay.zip \
  src/sim/turn.ts \
  src/sim/types.ts \
  src/sim/peopleFirst.ts \
  src/sim/court.ts \
  src/App.tsx \
  tests/v0271_hotfix_p0_correctness.test.ts \
  DEV_NOTES.md
```

